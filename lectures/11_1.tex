\section{Разбор задач семинара}

\begin{enumerate}
\item 
    \begin{proof}
    \begin{enumerate}
    \item 
    $O(n^2)$

    \cpp"dp[i][j][k] = len" максимальная длина последовательности если 
    разобрали первые i в первой строчке, j во второй и остановились последовательность заканчивается на k.

    Давай-те сделаем \cpp"dp[i][j] = len", при этом мы взяли i и j.

    При переходе нужно перебрать элементы, которые были до нас.

    $$dp[i][j] = dp[p][q], p, q\colon p < i, q < j, a[p] == b[q], a[p] < a[i]$$

    Квадрат состояний и квадрат переходов.
    \item

    Динамика за $O(n^3)$.
    \cpp"dp[i][j] =" максимальная длина подпоследовательности, заканчивается в \cpp"a[i]", и в префиксе \cpp"b[j]".

    \cpp"last[a[i]][j] =" для \cpp"a[i]" последний элемент раньше в b раньше j равный \cpp"a[i]".

    Теперь нужно найти максимальную общую возрастающую, которая заканчивается раньше i и раньше
    \cpp"last[a[i]][j]".

    $$dp[i][j] = max_p dp[p][last[a[i]][j] - 1]$$ 

    \item можем заметить, что сейчас у нас максимум очень простой. Какой-то на префиксе. Предподсчитаем
    максимум на префиксе.  $$pref_dp[i][j] = max_{0 \le p \le i} dp[p][j] = max(dp[i][j], pref_dp[i - 1][j])$$

    $$dp[i][j] = pref_dp[i - 1][last[a[i]][j] - 1]$$ 
    
    Динамика за $O(n^2)$
    \end{enumerate}
    \end{proof}
\item   
    \begin{proof}
    Будем хранить два последних элемента последовательности и для них самую длинную 
    выпуклую подпоследовательность. Можем перебрать элемент k, который был еще раньше $a_j < \frac{a_k + a_i}{2}$.

    $$dp[i][j] = 2$$
    $$dp[i][j] = max_k dp[j][k] + 1 (k \colon a_j < \frac{a_k + a_i}{2}) $$
    \end{proof}
\item 
    \begin{proof}
    Смотрим на число и смотрим, сколько чисел начинается на данную цифру. 

    Если мы знаем количество чисел, которые начинаются на x, то нужно прибавить к ответу 
    Все числа, которые начинаются на цифру меньше x.

    Далее мы свели задачу к числу с меньшим количеством чисел. 
    
    $dp[k][n]$ "---  количество чисел, которые начинаются на k и имеют длину n.

    $$dp[k][n] = \sum_{1 \le p \le 9 \colon |p - k| \ge 3} dp[p][n - 1]$$

    Нужно быстрее $O(N D^2)$, но нам не нужно каждый раз считать 
    сумму, мы можем ее предподсчитать.

    \end{proof}
\item
    \begin{proof}
    \begin{enumerate}
    \item 
    Построили число, нужно знать длин, сумму и последнюю цифру. Считаем количество чисел. 

    $$dp[S + dp][N + 1][D_2] = dp[S][N][D]$$

    $O(S \cdot D^2 \cdot N)$
    \item Нам нужно хранить сумму всех цифр, последнее число хранить не надо. 
    $$(d_1 + d_2 + \cdots + d_n)^2 = \sum d_i^2 + 2 \sum d_i d_j $$
    \end{enumerate}
    \end{proof} 
\item 
\begin{proof}
Динамика по подотрезкам. 

Рассмотрим первую скобку. Есть два варианта, что с ней делать: удалить или оставить.

Если удалили, то решаем задачу без нее и к ответу +1.

Если оставили, то нужно найти ей пару, дальше нужно независимо решить задачу внутри скобок и во внешнем мире.

Решаем задачу в подстроке от L до R
$$dp[L][R] = min(k \colon (s[L] \text{и} s[k] \text{"--- пара}) dp[L + 1][k - 1], dp[L + 1][R] + 1)$$

Отрезки нужно перебирать в порядке увеличения их длины.  А можно считать динамику лениво. 
\end{proof}
\item 
\begin{proof}
i из верхнего поддерева, j  из нижнего, w текущее ребро.

k "--- размер поддерева.
$$\sum_{i, j} (p_i + w + q_j)^2 = \sum (p_i^2 + w^2 + q_j^2 + 2wp_i + 2wq_j + 2p_iq_j) = $$
$$ = (n - k)\sum p_i^2 + k \sum q_j^2 + k(n - k)w^2 + 2w(n - k) \sum p_i + 2wk\sum q_j + 2 \sum p_i q_j$$
$$\sum p_i q_j = \sum p_i \sum q_j$$
\end{proof}
\item
\item 
\begin{proof}
Если у корней количество детей разное, то все сразу плохо, иначе, нужно как-то переставить детей. 

Давай-те сопоставлять деревьям чиселки и у изоморфных деревьев будет одинаковое число. 

Запускаем обход по дереву. 
\cpp"map <vector<int>, int>"

По множеству детей нужно понимать, видели мы такое раньше или нет. Если видели, то присваиваем
такой же номер, иначе присваиваем какой-то уникальный.

В целом, можно считать полиномиальный хеш.  
\end{proof}  
\item 
\begin{proof}
    \begin{enumerate}
    \item 
    dp[x] "--- можем ли мы набрать вес x, если можем, то какой последний предмет мы положили.
    $$\forall s \colon dp[s] \ne NULL \colon dp[s + w_i] = i$$

    Слева направо идти не можем, поскольку будем использовать один предмет два раза. Можем идти с другой стороны, 
    в порядке уменьшения весов и все будет ок. 
    \begin{cppcode}
    for i = 1 .. n
        for s = w .. 0
            if dp[s - w_i] && !dp[s] {
                dp[s] = 1;
                p[s] = i;
            }
    \end{cppcode}

    \cpp"!dp[s]" "--- важное условие. 

    Иначе есть пример, когда мы в восстановление ответа будем использовать один слиток два раза. 
    \end{enumerate}

\end{proof}
\end{enumerate}
