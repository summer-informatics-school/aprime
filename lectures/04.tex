\chapter{Least Common Ancestor}

\section{Тривиальный алгоритм}
Времена входов и выходов. 
Необходимо проверить, является ли одна вершина предком другой. 
Посчитаем времена входов и выходов. Заметим, что если вершина v, является
предком u, то мы зашли раньше в v и вышли из v позже. 
              
\textbf{Тривиальный алгоритм обхода:} поднимаем вершинку вверх, пока она не станет 
предком другой.
Или поднимаем вершинки до одного уровня, а потом прыгаем, пока не станем одной вершинкой.

\section{Двоичные подъемы, вычисление функции на путях}

Предподсчитаем массив \cpp"p[v][k]" = куда мы попадем, если прыгнем вверх на $2^k$.

\cpp"p[v][0]" = просто предок. 

\begin{cppcode}
for (int i = 1; i < maxk; ++i) {
    for (int v = 0; v < n; ++v) {
        p[v][i] = p[p[v][i - 1]][i - 1];
    }
}
\end{cppcode}

Способы подсчета LCA
\begin{enumerate}
\item 

    \begin{cppcode}
    int lca(int u, int v) {
        if (h[u] > h[v]) swap(u, v);
        for (int k = maxk - 1; k >= 0; --k) {
            if (h[p[v][k]] >= u) {
                v = p[v][k];
            }
        }
        for (int k = maxk - 1; k >= 0; --k) {
            if (p[v][k] != p[u][k]) {
                v = p[v][k];
                u = p[u][k];
            }
        }
        if (v != u) {
            return p[v][0];
        } else {
            return v;
        }
    }
    \end{cppcode} 
\item
 
    \begin{cppcode}
    int lca(int v, int u) {
        for (int k = maxk - 1; k >= 0; --k) {
            if (!is_parent(p[v][k], u)) {
                v = p[v][k];
            }
        }
        if (is_parent(v, u)) return v;
        else return p[v][0]; 
    }
    \end{cppcode}
\end{enumerate}

Если функция обратима, то можно посчитать функцию от корня до вершины. 

\cpp"(sum(u, v) = sum(u) + sum(v) - 2sum(lca(u, v)))"

Если функция ассоциативна, разбить путь на log кусков как в двоичных подъемах и значения предподсчитываем. 
В первом способе можем считать функцию по ходу, во втором нужно сначала вызвать lca(u, v), а потом lca(v, u).
\section{СНМ}
Система непересекающихся множеств.

Нужно уметь объединять множества и узнавать лежат ли вершины в одном множестве. 

\begin{enumerate}
\item
Тупое решение: массив цветов, перекрашиваем, когда сливаем. 

Заметим, что если будем перекрашивать то, что меньше, то сложность в итоге будет $O(N \log N)$, поскольку 
каждая вершина, когда перекрашивается, оказывается в множестве хотя бы в два раза большем. А отвечаем на запросы совсем за быстро.
\item
Можем хранить лес, и подвешивать одно дерево к другому, когда сливаем. Дальше проверяем, что корень один и тот же.
\end{enumerate}

Эвристики у последнего решения
\begin {enumerate}
\item Сжатие пути

Ответ за $O(\log n)$.

Рассмотрим три вида ребер: корневые, тяжелые (ребра, на которых висит более половины поддерева), легкие.

Заметим, что на пути у нас встретится только одно корневое ребро. Легких
не больше $\log$ на пути (каждый раз поддерево увеличивается хотя бы в два раза).

Теперь разберемся с тяжелыми ребрами.
Рассмотрим вершину, когда она стала не корнем. Ее размер больше не увеличится. Если мы пройдем 
по тяжелому ребру в вершину, то ее поддерево уменьшится хотя бы в два раза. Значит количество переходов по тяжелым ребрам в эту вершину не более $\log$.

\item Ранговая эвристика
Глубина не больше $\log n$. 

Докажем по индукции. 

Одна вершина ранг = 0, количество вершин 1.

Теперь пусть верно для k и размер хотя бы $2^k$, тогда если 
у нас увеличился ранг, то  два дерева равны по рангу и значит размер 
дерева ранга k + 1 хотя бы $2^{k  + 1}$.

\end{enumerate}
\section{Алгоритм Ахо-Хопкрофта-Ульмана-Тарьяна}

У вершин три цвета:
\begin{enumerate}
\item белые "--- еще не трогали
\item серые "--- сейчас обрабатываем (предки)
\item черные "--- закончили обработку.
\end{enumerate}

Изначально каждая вершина в своем множестве. 

При обработки вершины v:
\begin{enumerate}
\item u "--- пара v и u черная, тогда
\cpp"lca(u, v)" = вершина с min высотой в множестве u.
\item Заканчиваем обработку вершины, красим в черный, присоединяем к множеству предка. 
\end{enumerate}

$O(\log^* n + m)$

\section{Sparse Table} 
\cpp"m[i][0] = a[i];"

\cpp"m[i][k] = max(m[i][k - 1], m[i + (1 << (k - 1))][k - 1])"

Ответ на запрос \cpp"max(m[k][l], m[k][r - (1 << k)])"

$O(n \log n)$ "--- память предподсчета. 

$O(1)$ "--- запрос.

\section{LCA -> RMQ}

Записываем в массив вершину, когда в dfs заходим в вершину и выходим из любого его ребенка.

Для ответа на запрос нужно найти два любых вхождения u и v и найти минимум по высоте на отрезке.
