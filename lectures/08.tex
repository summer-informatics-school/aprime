\chapter{Персистентные структуры данных}
Можем изменять и обращаться к любой версии объекта.
\section{Персистентный стек}
Нельзя изменять значения элементов, для всего нужно создавать новое.
\textbf{Метод копирования путей(part coping)}
\begin{cppcode}
struct Node {
    int value;
    Node* next;
};

Node* push(Node* s, int x) {
    Node* res = new Node;
    res->next = s;
    return res;
}

pair <int, Node*> pop(Node * s) {
    return make_pair(s.value, s.next);
}
\end{cppcode}

\cpp"Node[]" "--- значение элементов стека.
\cpp"st[]" "--- указатель на последний элемент стека во времени.

\section{Дерево отрезков}
Каждый раз при изменение создаем новую вершину, а не копируем старую.

\begin{cppcode}
struct Node {
    Node *L, *R;
    int value;
};

Node* update(Node *v, int lv, int rv, int p, int x) {
    if (l + 1 == r) {
        return new Node(0, 0, x);
    }
    int m = (l + r)/2;
    if (p < m) {
        Node *nL = new Node;
        nL = update(v, lv, m, p, x);
        return new Node(nL, R, nL.val + R.val);
    }
}
\end{cppcode}

Памяти $O(n + m \log n)$

Время: $O(m \log n)$

\textbf{Задача:} Онлайн отвечать на запрос количество точек внктри прямоугольника.
Ответ на запрос $O(\log n)$
\begin{proof}
По y дерево отрезков, по x сканлайн. 

Событие: встертили точку, увеличели соответствующее значение в персистентном дереве отрезков.

Запрос прямоугольник: бинпоиском находим позицию, где начинается и заканчивается
праямоугольник. sum(в правом дереве на нужном отрезке) - sum(в левом на отрезке).
\end{proof}

\textbf{Задача:} k-ая порядковая статистика на отрезке.

Идем в массиве сканлайном, если втретили элемент, изменяем счетчик в персистентном 
дереве отрезков.

Теперь при ответе на запрос, будем параллельно спускаться в двух деревьях. 
$D[i] = D_r[i] - D_l[i]$  "--- количество элементов на отрезке [l, r].

Ответ на запрос $O(\log n)$.

\section{Персистентное декартово дерево}
Хотим сделать персистентный \texttt{Treap}. Казалось бы, можно просто брать и каждый раз не менять вершину, а 
создавать ее копию и работать с ней. Но тогда у нас в какой-то момент может взять и сломаться балансировка.
А именно, у нас могут появляться одинаковые $y$ у вершин. 
Более того, если мы будем делать запросы вида \cpp"r = merge(r, r)" кучу раз, то таких вершин будет реально много.
Пусть у нас была такая реализация \texttt{merge}:
\begin{cppcode}
Node *merge(Node *a, Node *b){
    if (a == NULL) return b;
    if (b == NULL) return a;
    if (a->y >= b->y) {
        a->r = merge(a->r, b);
        return a;
    } else {
        b->l = merge(a, b->l);
        return b;
    }
}   
\end{cppcode}
То после повторения в цикле такой операции: \cpp"r = merge(r, r)", мы получим бамбук, направленный вправо.
Пусть мы повторили эту операцию $m$ раз, тогда размер дерева стал $2^m$, и его глубина тоже стала $2^m$ 
вместо желаемой $m$.

Решение этой проблемы достаточно простое. Просто не будем хранить $y$ в вершине. 
Вспомним, зачем нам нужны были случайные $y$. 
Мы говорили, что если все $y$ будут случайными, то полученное дерево тоже будет случайным, то есть каждая вершина
будет корнем с одинаковой вероятностью. 
Ну давайте это возьмем и реализуем.

\begin{cppcode}
Node* merge(Node* a, Node* b) {
    if (a == 0) return b;
    else if (b == 0) return a;
    else if (random(a.size() + b.size()) < a.size) {
        return (Node(a.x, a.y, a.L, merge(a.R, b)));
    } else {
        return (Node(b.x, b.y, merge(a, b.L), b.R));
    }
}
\end{cppcode}

Рассмотрим все вершины, входящие в $a$ и $b$. 
Мы хотим, чтобы корень был случайной вершиной. 
Тогда вероятность того, что корень будет лежать в $a$ это как раз и есть \cpp"a->size / (a->size + b->size)", то есть данный
код нам как раз дает RBST.

\subsection{Копирование отрезков}
Выделяем фиксированную память, когда память кончилась, выписываем дерево, очищаем память, 
строим дерево заново.