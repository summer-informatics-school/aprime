\chapter{Разделяй и властвуй и meet-in-the-middle}

Есть большая задача, мы не знаем, что с ней делать.

Разделим на две части и решим для них рекурсивно. После этого 
нужно перебрать решения, которые пересекают границу разреза. Самое 
сложное “--- найти ответ на границе разреза. 

\section{Найти две ближайшие точки.} 
    \begin{proof}
        Можно в тупую за квадрат. Хотим быстрее. 
        \begin{enumerate}
        \item
        Отсортируем точки по x и разделим их на две половины. 
        
        Точки сортируем по x один раз. В дальнейшем точки уже будут отсортированы по x и
        мы сможем разделять на две отсортированных части линейным проходи. 
        
        Запоминаем какой номер был в какой половине, в не координаты(проблема с повторяющимися точками).
        \item
        Решим задачу рекурсивно. Получили ответ $d_1$ и $d_2$ и нужно учесть 
        точки из разных половин. 

       $d \le min(d_1, d_2)$. Поэтому рассматривать пары, которые очень далеко не имеет смысла, они нам не помогут. 

       Остались только точки которые не далеко от линии разреза, на расстояние не более $d = min(d_1, d_2)$. При этом 
       может так получиться, что мы вообще не отсекли никакие точки. 

       Посмотрим на интересную точку. Хотим для нее найти точку из другой половины на расстояние меньше $d$. Ограничим точку и 
       по координате $y$. То есть все интересные пары для точки находятся в квадрате $2d \times 2d$.

       Если мы будем искать точку только в верхнем квадрате, то тоже все нормально, мы только обозначили, что первая точка в паре снизу.

       Теперь давай те думать, сколько точек может быть в одном квадрате $d \times d$ в одной из половин. Не более 4, поскольку между
       любой парой точек в квадрате расстояние не меньше d.
       \item
       Когда мы находимся на границе, оставляем только точки, которые находятся на расстояние не больше d от границе  по x.
       \item
       Сортируем эти избранные точки по y. Добавляет лишний $\log$, это грустно. Давай те передавать массив не только
       отсортированный по x, но и по y. Тогда рекурсивно создавать эти массивы мы можем за линию. Проходимся и смотрим, в какую половину нужно
       отправить точку. 
       \item
       Для каждой точки кандидаты будут только следующие 8 точек. Переберем их и посчитаем расстояние.  
       \begin{cppcode}
       for (int i = 0; i < k; ++i) {
           j = i + 1;
           while (y[j] <= y[i] + d) {
               //проверяем i и j
               ++j;
           }
       }
       \end{cppcode}
       \end{enumerate}
        Оценим время. При сливе работаем за $\O(n)$, на следующем слое работали за $2 \cdot \frac{n}{2} \cdots$. 
        Слоев $\log n$, время $O(n \log n)$

    \end{proof}
\section{Рюкзак}
 Есть веса $w_1 \cdots w_n$ и стоимости $c_1 \cdots c_n$, не можем набрать вес больше $W$, хотим 
максимизировать стоимость. 

$w_i \le 10^{16}$, $n \le 32$.
\begin{proof}
Умеем решать за:
   \begin{enumerate}
   \item $O(2^n)$
   \item $O(Wn)$
   \end{enumerate}

Давайте разделим все предметы на две части, теперь в каждой части по 16 предметов. В половинах можем все перебрать, и задача для половин решена.

Теперь надо слить решения.

Если мы зафиксировали подмножества из правой части, то мы знаем вес, который мы уже взяли $W'$, тогда из другой части интересны только
подмножества с весом не больше, чем $W - W'$.

Отсортируем по $W$ подмножества, а дальше нужно искать максимум на префиксе. Границу в массиве можем найти бинпоиском ну или с помощью двух указателей.

Считаем сложность: 
$$2^{\frac{n}{2}} + 2^{\frac{n}{2}} + 2^{\frac{n}{2}} \frac{n}{2} + 2^{\frac{n}{2}}(\frac{n}{2} + 1) = O(n 2^\frac{n}{2})$$   
\end{proof}
\section{Dynamic Connectivity Offline}

Неориентированный граф $G = (V, E)$, запросы:
    \begin{enumerate}
    \item добавить ребро
    \item удалить ребро
    \item находятся ли вершины в одной компоненте. 
    \end{enumerate}
\begin{proof}
\begin{enumerate}
\item
У нас есть куча запросов, давайте, мы их разделим на две части. Если бы не было удалений, то это просто СНМ, если только 
добавление, то СНМ с конца, а так грустно. 

Давай те у каждого запроса будет пара, если добавили ребро, пара “--- когда удалим. 

В начале добавим запросы добавить ребра которые и так были и в конце добавим запросы удалить все ребра, которые есть. Считаем, что
кратных ребер нет.

Сопоставим каждому запросу пару, как-нибудь это сделаем. 
\item Разделили на две части запросы и что мы видим. 
Есть ребра, которые всегда есть, которых всегда нет, а есть какие-то плохие,
которые иногда есть, иногда их нет.

Если один запрос, то можем на него ответить. Если 
запросов много, делим на две части
\item 
Когда разделили на две части, нужно передать СНМ с правильными ребрами(которые не меняются на этом отрезке).

Нам нужно в СНМ добавить ребра, у которого запрос добавления начинается до первой половины, и заканчиваются во второй половине. 
Перебираем все запросы удаления из правой части.

$dsu \Ra dsuL$.

Получили для L, можем запускаться рекурсивно для левой половины.

\item Теперь нужно как-то получить $dsuR$. Мы испортили снм, копировать
его полностью не можем, поскольку долго. 

Не умеем $dsuL \Ra dsuR$, нам бы как-то вернуться к $dsu$.

Если мы запомнили, что и где мы присваивали, то можно присвоить все обратно за 
столько же операций. 

Тогда мы смогли получить из $dsuL \Ra dsu$ и можем перейти к $dsuR$, победа. 

\item Теперь более подробно про откатывание изменений. 

Сохранить u и par[u], rank[v].
par[u] = v;

Все пихаем в стек и в обратом порядке, откатиываем.

Сжатие путей нам не особо помогает, мы старались, а потом откатились.
Достаточно использовать только ранговую эвристику. 

Ранговая эвристика работает за $O(log n)$, а ранговая эвристика + сжатие путей тоже $O(log n)$.

\end{enumerate}
\end{proof}

\section{Максимальный тандемный повтор}
\begin{Def}
Строка S.
T строка.
T тандемный повтор S "--- если в S встречается подстрока TT.
\end{Def}

\begin{proof}
Если будем много букв a, тогда тандемных повторов будет примерно $\frac{n^2}{4}$.

Разделим строку на две части, запустимся рекурсивно от двух частей. 

Осталось рассмотреть тандемные повторы, которые пересекаются с серединкой. 

Длина TT = $2k$. Символу i будет равен символ i - k, но k мы пока не знаем.
Пусть $k = k_1 + k_2$, с левой стороны находятся $k_1 + k_2 + k_1$ символ, во второй части $k_1$.

Когда мы зафиксировали k, то 
$$k_1 \le lcs(s[0:i - k - 1], s[0:i - 1]) = X_1$$ 
$$k_2 \le lcp(s[i - k:], s[i:]) = X_2$$

Если мы найдем $X_1 и X_2$, то мы справимся. $X_1$ и $X_2$ можем найти
 с помощью z-функции сток s[i:n - 1]\#s[0:i] и s[i - 1: 0].

Время работы $O(n \log n)$
\end{proof}
\section{Алгоритм Карацубы}
$A \cdot B$ хотим перемножить, большие числа.

$base = 10^4$, храним числа в массиве интов. 

$c[i + j] += a[i] \cdot b[j]$

Время: $O(n^2)$.

Давай те при перемножении, разделим числа на две части.
$$A = A_1 base^{k} + A_0$$
$$B = B_1 base^{k} + B_0$$

$$AB = A_1 B_1 base^{2k} + (A_0B_1 + B_0 A_1)Base^{k} + A_0B_0$$

$$T(n) = 4T(\frac{n}{2}) + O(n)$$
$$T(n) = O(n^2)$$
$$T(k) = O(k^2)$$
$$T(2k) = 4T(k) + O(2k) = 4O(k^2) = O((2k)^2)$$

Попробуем выразить $A_0B_1 + B_0 A_1$

$$(A_0 + A_1)(B_0 + B_1) = A_0B_0 + A_1B_1 + (A_0B_1 + A_1B_0)$$


$$T(n) = 3T(\frac{n}{2}) + O(n)$$
$$T(n) = O(n^{\log_{2}3})$$