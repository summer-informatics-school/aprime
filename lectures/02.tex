\section{Ахо-Корасик}
\begin{Def}
Суффиксная ссылка "--- максимальный суффикс этой строки, 
который встречается в боре от корня и не совпадает с данной строкой. 
\end{Def}

Если в бор добавлена одна строка, то это префикс-функция. 

Хотим научиться находить слово из словаря в тексте (образец это подстрока, а не 
слово целиком, иначе умеем решать хешами). 

\textbf{Решение:}

$O(n^2)$
\begin{enumerate}
\item добавляем в бор слова 
\item p "--- предок

с "--- символ на ребре к предку. 

go[v][c] "--- переход по символу c из вершины v, (-1, если нет перехода). 

\begin{cppcode}
k = suflink(p)

while (go[k][c] == -1)
    k = suflink(k);
\end{cppcode}

Работает корректно, аналогично префикс-функции. 

Нужно найти как можно больший суффикс без одного символа и перейти по символу a.
\end{enumerate}

Оптимизация: (Ахо-Корасик)

\begin{enumerate}
\item Храним \cpp"next[v][c] =" куда мы попадем, если будем прыгать несколько раз (может быть ноль) по 
суффиксным ссылкам, а потом один раз по данному символу с.


Чтобы узнать \cpp"next[v][c]": 
    \begin{enumerate}
    \item если мы можем перейти по символу с, то узнали.
    \item если не можем, то идем по суффиксной ссылке и узнаем next от него.
    \end{enumerate}
\item Идем по суффиксной ссылке предка и узнаем, куда мы попадем по символу с.
\end{enumerate}

Если по суффиксным ссылкам можем добраться до терминальной, то мы тоже терминальные.

\begin{cppcode}
next[M][26];
suffix[M];
terminal[M];

start = 0;

for (c = 0; c < 26; ++c) {
    if (next[start][c] == -1) {
        next[start][c] = start;
    } else {
        suffix[next[start][c]] = start;
        que.push_back(next[start][c]);
    }
}

while (que.size() > 0) {
    x = que.front(), que.pop_front();
    for (c = 0; c < 26; ++c) {
        if (next[x][c] == -1) {
            next[x][c] = next[suffix[x]][c];
        } else {
            suffix[next[x][c]] = next[suffix[x]][c];
            que.push_back(next[x][c]);
        }
    }
}
\end{cppcode}     

\section{Суффиксный массив}
\subsection{Поразрядная сортировка}
\begin{enumerate}
    \item Сортируем подсчетом по последнему символу.
    \item Рассмотрим предпоследний символ и отсортируем подсчетом по нему, 
    но устойчивой сортировкой. 
    \begin{enumerate}
    \item считаем размер корзин.
    \item считаем суммы на префиксах этих корзин.
    \item в данном массиве записано место, на котором должен стоять данный элемент.
    После постановки элемента увеличиваем размер ячейки. 
    \end{enumerate}

\end{enumerate}   

\subsection{Алгоритм Карпа-Миллера-Розенберга}

\begin{enumerate}
\item Вместо суффиксов будем сортировать циклические сдвиги. Дописываем в конец строки решетку(очень легкий символ).
\item Умеем сортировать строки длины один (подсчетом).
\item Хотим перейти от $L$ к $2L$.

Нужно отсортировать пары <c[i], c[i + L]>

c "--- номер класса эквивалентности

suf "--- место в отсортированном массиве строчек данной длины.

\cpp"while (L < N)":
\begin{enumerate}
    \item \cpp"suf[i] = (suf[i] - L)%N" (отсортировали по второму символу в цифровой сортировке)
    \item Считаем сколько какого класса эквивалентности. 
    \item Вычисляем позицию для записи(суммы на преффиксах)
    \item Записывем новый суффиксный массив:
    \begin{cppcode}
        for (int i = 0; i < n; ++i) {
            n_s[cnt[c[suf[i]]]++] = suf[i];
        }
    \end{cppcode}
    \item Пересчитываем классы
    \begin{cppcode}
    for (int i = 0; i < n; ++i) {
        if (i == 0 || (c[n_s[i]], c[n_s[i] + L]) != 
                      (c[n_s[i - 1]], c[n_s[i - 1] + L])) {
            n_c[n_s[i]] = n_c[n_s[i - 1]] + 1;
        }
    }
    \end{cppcode}
    \item Копируем, \cpp"c = n_c", \cpp"suf = n_suf".
\end{enumerate}

\end{enumerate}

\section{LCP, алгоритм Аримуры-Арикавы-Касаи-Ли-Парка}
LCP = largest common prefix

LCP(i, j) = min lcp[i $\cdots$ j]

За линию посчитаем LCP соседних суффиксов. 

\begin{enumerate}
\item рассмотрим самый длинный суффикс. Считаем его lcp. 

Пусть lcp = x, тогда у следующего суффикса по длине lcp хотя бы x - 1

Факт, что без одного отрезанного символа суффиксы будут располагаться в том же порядке, но, может быть, не подряд. 
(Доказывается как-то просто, надо порисовать).


\begin{cppcode}
x = 0;
for (int i = 0; i < n; ++i) {
    while (s[i + x] == s[suf[where[i] + 1] + x]) ++x;
    lcp[where[i]] = x;
    x = max(0, x - 1);
}
\end{cppcode}
\end{enumerate}                                  
