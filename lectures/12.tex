\section{Динамика по подмножествам}
\begin{enumerate}
\item 
Задача о паросочетание с произвольном графе. 

\begin{proof}
    Для построения паросочетания нам важно знать только множество вершин, которое мы используем, какие именно ребра нам не важно. 

    \cpp"dp[mask]" "--- можно ли построить паросочетание, насыщающие только эти вершины. Заметим, что размер паросочетания можно 
    легко восстановить из маски $\frac{cnt}{2}$.

    $$dp[mask] = OR_{(u, v) \in E; u, v \in mask} dp[(mask \setminus \{u, v\})]$$
    $$u \in mask \Lra ((mask >> u)\&1) == 1$$
    $$mask \setminus u \Lra (mask \& (~(1 << u))$$
    $$dp[0] = true$$
    Можно считать динамику в порядке возрастания маски (for mask = 1 ... $2^n - 1$).

    Получили массив dp, теперь нужно найти маску с максимальным количеством бит. Так же можно для маски хранить последнее ребро. То есть, 
    массив предков. 

    Время работы $O(2^n m)$
\end{proof}
\item Хотим раскрасить вершинки в цвета, так, что бы вершины одинакового цвета не 
были соединены ребром. 
\begin{proof}
    Выберем независимое подмножество вершин и красим в нулевой цвет. Еще раз выбираем независимое множество и красим$\cdots$.
    dp[mask] "--- минимальное количество цветов для покраски вершин из маски.
    $$dp[mask] = min_{mask2 \subset mask} dp[mask \setminus mask2] + 1$$
    $$mask2 \subset mask \Lra (mask2 \& mask)== mask2$$

    \begin{cppcode}
    for (int mask = 1; mask < (1 << n); ++mask) {
        for (int mask2 = 1; mask2 <= mask; ++mask2) {
            if (mask2 /* подмножество */ mask && mask2 /* независимое */) {
                //обновляем dp[mask]    
            }
        }
    }
    \end{cppcode}

    Работает за $O(4^n \cdot n^2)$.

    Разберемся с проверкой независимого множество. Можно заранее для каждой маски проверить, является ли множество независимым. 

    dp2[mask] "--- является ли маска независимым. 

    Давай те теперь соптимизируем перебор подмножеств. 
    
    Посчитаем количество пар, что одно из множеств является в подмножестве другого. 

    Есть  элементы, которые лежат в маске, которые лежат в маске и подмаске и которые нигде не лежат. То есть 
    для каждого элемента три варианта множества, куда мы можем его положить. Значит всего пар $O(3^n)$.
    
    Теперь нужно научиться перебирать только те маски, которые нам нужны.
    \begin{cppcode}
    for (int mask = 1; mask < (1 << n); ++mask) {
        for (int mask2 = mask; mask2 != 0; mask2 = (mask2 - 1)&mask) {
            ...
        }
    } 
    \end{cppcode} 

    Есть произвольная mask. Посмотрим на какой-то mask2. При таком переходе mask2 всегда подмножество. 

    Теперь из mask2 вычитаем 1. Тогда самая правая 1 становится 0, все раньше остается таким же, все после стоят 1. 
    То есть в значимых битах мы переходим к следующему числу, а не значимые всегда остаются 0.

    То есть  мы перебрали ровно все подмаски.
     
\end{proof}
\end{enumerate}
\section{Динамическое программирование по профелю}
Количество способов замостить доску доминошками. 
\begin{proof}
dp[i][mask] "--- количество замощенных первых i столбцов + в i столбце торчат доминошки в позициях mask.

dp[i + 1][mask2] Понятно, где стоят горизонтальные доминошки, проверяем что все дырки для вертикальных доминошек четные. 
Если есть нечетная, то нельзя перейти и количество способов 0, иначе 1. 

\begin{cppcode}
for (int i = 0; i < m; ++i) {
    for (int mask = 0; mask < (1 << n); ++mask) {
        dp[i][mask] //"--- уже лежит правильный ответ. 
        for (int mask2 = 0; mask2 < (1 << n); ++mask2) { 
            if (good(mask, mask2)) { 
                // так же плохо, если что-то 
                //торчало в mask и там же торчит в mask2.
                dp[i + 1][mask2] += dp[i][mask];
            } 
        }
    }
}

bool good(mask, mask2) {
    if ((mask & mask2) != 0) return false;
    free_mask = (mask | mask2) ^ ((1 << n) - 1); //то, что нужно заполнить 
    //вертикальными доминушками.
    //Проходимся циклом, находим единичку, 
    //если следующий тоже единичка выкидываем оба, иначе плохая маска.   
}
\end{cppcode}

Ответ лежит в dp[n][0].

Работает за $O(m \cdot 4^n \cdot n)$.

Память $O(2^n m)$.

Можем предподсчитать для каждой маски, можно ли добить ее вертикальными доминошками. 
Теперь время $O(m \cdot 4^n)$.

\begin{Rem}
$n < m$, если не так, то надо swap.

$n \cdot m \le 100$, это значит, что хотя бы одна меньше 10.
\end{Rem} 

Еще можем перебирать только подмножество дополнений, теперь получилось $O(m \cdot 3^{n})$.
\end{proof}
\section{ДП по изломанному профилю}
Это не сложнее, чем обычный профиль.

Задача та же.
\begin{proof}
Теперь мы будем добавлять по одной доминошке.  

dp[i][j][mask] "--- полностью покрыли первые i строк, j первых тоже покрыли, и есть изломанная интересная маска торчащих доминошек.

Если ($j \in mask$) dp[i][j + 1][$mask \smallsetminus \{j\}$]

Если (j не в маске) dp[i][j + 1][$mask \cup \{j\}$] и 

если(j + 1 не в маске) dp[i][j + 1][$mask \cup \{j + 1\}$]

Если (j == n) dp[i + 1][0][mask]

\begin{cppcode}
dp[0][0][0] = 1
for (int i = 0; i < m; ++i) {
    for (int j = 0; j < n; ++j) {
        for (int mask = 0; mask < (1 << n); ++mask) {
            if (j in mask) {
                dp[][][] += dp[i][j][mask];
            } else {
                dp[][][] += dp[][][];
                if () {
                    dp[][][] += dp[][][];
                }
            } 
        }
    }
    for (int mask = 0; mask < (1 << n); ++mask) {
        dp[i + 1][0][mask] += 
    }
}
\end{cppcode}

Время работы $O(n \cdot m \cdot 2^n)$.
Память $O(n \cdot m \cdot 2^n)$
\end{proof}
\section{bfs}
Есть много прямоугольников, какие-то можем двигать по вертикали, некоторые, по горизонтали. Нужно вытащить прямоугольник через дырку. 

Можем считать, что каждое состояние "--- это вершина. Если можно перейти из одного состояния в другое, то есть ребро. 
Считаем хеш от позиции. У каждого прямоугольника можем записать координату и посчитать хеш от строки. 

Запускаем на таком графе bfs, поскольку нужно найти кратчайший путь. 

Непонятно, за сколько это работает, но это работает.