\chapter{Структуры данных}

Все люди делятся на две части: на тех, кто ходят пешком 
и тех, кто ездит на машине. Те, кто ездит на машине делятся на две части: 
те, кто ездят на переднем сиденье и на заднем. Те, кто ездит на переднем сиденье 
делятся на две части: те, кто пристегивается и те, кто не пристегивается. Те, кто не 
пристегивается: делится на две части, те, кто попадает в аварии и те, кто не попадает в аварии.

\section{Дерево отрезков} 

Отрезок от 1 до N продлим до $2^k$. 

Отрезки делятся каждый раз на две части. У i-ого элемента массива будут дети $2 \cdot i$ и $2 \cdot i + 1$.

Количество элементов в дереве отрезков $2 \cdot 2^{k} - 1$, первый элемент уровня "--- это степень двойки. 

\cpp"__builtin_ctz" "--- количество лидирующих нулей у числа. 

В дереве отрезков можно хранить, например, сумму на отрезке. 

\cpp"s[i] = s[2i] + s[2i + 1]" 

То есть дерево отрезков, вы можете построить за $O(N)$. 

На отрезке можно считать любые ассоциативные функции. 

Структура работает быстрее, чем отдельные массивы, из-за кеша. 
Выгоднее использовать unsigned int для деления  на 2, но в целом, это мелочи.

Напишем функцию обхода дерева.
\begin{cppcode}
walk(x, l, r) {
    if (l < r) {
        walk(2x, l, (l + r)/2);
        walk(2x + 1, (l + r)/2 + 1, r);
    }
}
\end{cppcode}

\subsection{Сумма на отрезке}
Переделаем функцию в сумму. 

\begin{cppcode}
//T[x] -> [l, r]
sum(x, l, r, a, b) { // сумма на пересечение отрезков l, r и a, b.
    if (r < a || b < l)  { // если  отрезки не пересекаются
        return 0;
    }
    if (a <= l && r <= b) { // если отрезок вложен. 
        return T[x];
    }
    return sum(2x, l, (l + r)/2, a, b) +
    sum(2x + 1, (l + r)/2, r, a, b);
}
\end{cppcode}

Почему дерево отрезков работает за $\log$? Раньше же функция обходила совсем все дерево. 

\begin{proof}
Легко заметить, что на одном уровне мы посетим максимум 4 вершины. Дальше индукция по уровням. Это чуть дольше,
чем дерево отрезков снизу, зато, у нас все функции будут писаться одинаково и в них будет сложнее ошибиться.  
\end{proof}

\subsection{Функция изменения в точке.} 

\begin{cppcode}
//T[x] -> [l, r]
change(x, l, r, a, b, v) { // изменение на пересечение отрезков l, r и a, b.
    if (r < a || b < l)  { // если  отрезки не пересекаются
        return;
    }
    if (a <= l && r <= b) { // если отрезок вложен. 
        T[x] = v;
    }
    change(2x, l, (l + r)/2, a, b);
    change(2x + 1, (l + r)/2, r, a, b);
    relax(x, l, r) // T[x] = T[2x] + T[2x + 1];

}
\end{cppcode}

\subsection{Изменение на отрезке}

Заметим проблемы в случае, если $a != b$. 
\begin{enumerate}
    \item Нужно присваивать другую сумму. 
    $T[x] = v \cdot (a - b + 1)$
    \item Нам нужно изменить сумму и на более мелких отрезках, 
    то есть если изменение на большом отрезке, то мы будем работать долго. 

    Лень двигатель прогресса, поэтому будем использовать ленивые вычисления и считать что-то только когда нам это пригодилось. 

    Заведем еще одно поле структуры, сколько мы присвоили на этом отрезке. 
\end{enumerate}


\begin{cppcode}
struct Node{ 
    int sum, assigned;
    bool was_assigned;
};

T[x].sum = ...
T[x].assign = v;
T[x].was_ass = 1;
\end{cppcode}

\begin{cppcode}
push(x, l, r) {
    if (T[x].was_ass) {
        T[x].was_ass = false;
        whole();
        whole();
    }
}

//T[x] -> [l, r]
change(x, l, r, a, b, v) { // изменение на пересечение отрезков l, r и a, b.
    if (r < a || b < l)  { // если  отрезки не пересекаются
        return;
    }
    if (a <= l && r <= b) { // если отрезок вложен. 
        whole(x, l, r) //
    }

    push(x, l, r);
    change(2x, l, (l + r)/2, a, b);
    change(2x + 1, (l + r)/2, r, a, b);
    relax(x, l, r) // T[x] = T[2x] + T[2x + 1];
}
\end{cppcode}

Дерево отрезков двоичное. Что будет, если сделать троичное дерево отрезков? Вы уже использовали корневое дерево отрезков, только 
там всего два уровня и вы их разбирали руками. 

Можно вместо суммы на отрезке, считать, например, хеш на отрезке. Это позволяет считать хеш на подотрезке за log и теперь вы можете еще и менять символ.

Даны две позиции i и j  и нужно посчитать LCP строк [i, n] и [j, n], и меняем какой-нибудь символ. Бинпоиск и хеши в дереве отрезков.

\subsection{Поиск по номеру в дереве отрезков.}
В вершине есть функция
\begin{cppcode}
search(x, l, r, i) {//ищит i-ый элемент на отрезке.
    ...
    if (i < T[2x].sum) {
        search(2x, ...)
    } else {
        search(2x + 1, ..., i - T[2x].sum);
    }
}
\end{cppcode}  

Очень похоже на написание сочетаний.
C(n, k) = 0, C(n - 1, k) либо 1, C(n - 1, k - 1);

Такая запись позволяет искать i-ый объект по номеру. По большому счету у нас написан бор.

Нужно искать объект самый больший меньше данного. Есть число от одного до 1000000 и найти самый большой элемент $\le k$.

Поставим 0 если число взято и 1 если не взято. Возьмем сумму от 1 до k, а потом вызвали функцию search(x, l, r, sum(k));

Другое решение, храним самую правую единицы.  У нас отрезок разбивается на log отрезков, найдем самый правую единицу в самом правом отрезке.

a, b, k самый левый меньше k на отрезке [a, b]. Будем хранить в вершинках еще и min. Разбиваем на левую и правую
часть, если min нам подходит, идем влево, иначе вправо.

Можно решать задачу, представляя отрезок разбитый на кусочки.

\begin{cppcode}
search(x, l, r, a, b, k) {
    if (/*не попало*/) return +inf;
    if (/*лист*/) return l;
    if (/*полностью лежит*/) {
        push
        if (/*слева все нормально*/) 
            return search(2x, ...);
        else return search(2x + 1, ...)
    }
    push
    return min(search(/*слева*/), (if /*не нашли ответ слева*/) search(/*справа*/));
}
\end{cppcode}

\subsection{Самый длинный черный подотрезок, перекрашиваем отрезок.}

Храним pref "--- самый длинный дчерный префикс, mid "--- самый длинный черный подотрезок, suff "--- самый длинный суффикс.
\begin{cppcode}
relax (x, l, r)
    if (T[2x].pref < T[2x].len) {
       T[x].pref = T[2x].pref
    } else {
       T[x].pref = T[2x].len + T[2x + 1].pref;
    }
    //для суффикса аналогично.
    T[x].mid = max(T[2x].suf + T[2x  + 1].pref, T[2x].mid, T[2x + 1].mid);                                      
\end{cppcode}