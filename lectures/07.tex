\section{Декартово дерево}

\begin{Def}
Декартово дерево "--- частный случай дерева поиска.
То есть все элементы меньше корня слева, все остальные справа.
\end{Def}

Но тут у нас есть произвол с выбором корня, например, если корнем каждый раз выбирать первый, то
получится бамбук.

Теперь у нас будут пары ($x_i, y_i$), и эти пары как-то будут нам говорить, кого поставить в корень.

Наложим на y ограничения двоичной кучи. Теперь каждому x будет сопоставлен y и корнем будем выбирать
элемент с максимальным y.

Не сложно доказать по индукции, что декартово дерево единственное.  Просто наличие y не решает проблему сбалансированности.
Например, можно взять все x равные y и получится плохое дерево. Можно доказать, что какую бы мы не взяли зависимость y от x, можно
придумать пример, когда глубин будет корень.

Но можно просто сопоставлять случайный y. Как будет генерироваться рандом?

srand(X) возьмем фиксированное, что бы при отладке не потерять баг, так же можно
подставлять разные ядра рандома и тестировать самим с собой. RAND\_MAX бывает достаточно не большой. Можно попробовать
делать высоты размера побольше.

В среднем высота дерева лежит между 2 и 3 log.

\textbf{Как построить декартово дерево?}

По каким попала парам за O(N) не построить, поскольку иначе мы решим задачу о сортировке.

Но если пары уже отсортированы, то можно построить за O(N).

Пусть мы дошли до $x_k$ и построили дерево для первых. Спускаемся до нужного места вниз, и переподвешиваем. Это долго, 
но если ходить не вниз, а вверх и решение за квадрат превращается в линию. Пусть, когда мы подвешиваем вершину, мы получаем доллар, 
а когда поднимаемся вверх, платим доллар, понятно, что мы не заплатим, больше чем получили, а вниз мы прошли за время O(N). 

Декартовы деревья очень удобно рисовать в декартовой системе координат.
Заметим, что каждая вершина соответствует какому-то отрезку x.     

\begin{cppcode}
struct Node {
     Node *left, *right;
     int x, y;
};

Node* search(Node *T, int k) {
    if (T == NULL) return NULL;
    if (k == T->x) return T; 
    if (k < T->x) return search(T->left, k);
    if (k > T->x) return search(T->right, k);
}
\end{cppcode}

Рекурсивная функция выглядит немного жестко, обычно ее пишут немного по-другому.

\begin{cppcode}
Node* search(Node *T, int k) {
    while(T && T->x != k) {
        T = k < T-> x?T->left: T->right;
    }
    return T;
}

\end{cppcode} 

Главные операции в декартовом дереве "--- это split и merge. Это обратные друг к друго операции. 

Split это разделение дерева на две части, заметно, что должно произойти что-то не тривиальное.

split T, k $\to$ L, R

merge L, R(L < R, все элементы из L строго меньше всех элементов из R) $\to$ T

\begin{cppcode}
typedef struct *Node tree;

void split(tree T, int k, tree &L, tree &R) {
    if (!T) {
        L = R = T;
        return;
    }   
    if (k < T->x) {
        split(T->left, k, L, T->left);
        R = T;
    } else {
        split(T->right, k, T->right, R);
        L = T;
    }
}

tree merge(tree L, tree R) {
    if (!L) return R;
    if (!R) return L;
    if (L->y > R->y) {
        L->right = merge(L->right, R);
        return L;
    } else {
        R->left = merge(L, R->left);
        return R;
    }
}
\end{cppcode} 

Функции очень похожи с точностью до замены x на y.

А теперь зачем все это? Мы хотели добавлять элементы в множества, а теперь что-то режим и что-то склеиваем.

Хотим добавить вершинку. Можем разделить по x, теперь сольем два раза. Это метод чайника, но можно добавить элемент за один 
спуск по дереву, а не за три. 

\begin{cppcode}
void add(tree& T, Node* N) {
    if (!T) {
        T = N;
        return;
    }
    if (N->y > T->y) {
       spilt(T, N->x, N->left, N->right);
       T = N; 
    } else if (N->x < T->x) {
        add(T->left, N);
    } else {
        add(T->right, N);
    }
}
\end{cppcode}

Удаление "--- это почти поиск, только нужно еще и удалить.

\begin{cppcode}
delete (tree& T, int k) {
    if (!T) {...}
    if (T->x == k) {
        T = merge(T->left, T->right);
    } else {
        if (k < T->x) {
            delete(T->left, k);
        } else {
            delete(T->right, k);
        }
    }
}
\end{cppcode}

Теперь из содержательной информации начнем хранить количество элементов в поддереве(int c).

Этот параметр будет релаксироваться достаточно естественным образом.

T->c = T->left->c + T->right->c + 1;

Проблема, если у нас есть NULL. Можно сделать функцию, которая возвращает размер,
а можно сделать специальную структуру, которая отвечает за NULL. Будем считать, что у нас есть специальная структура и
не будет проверять на NULL.


Сейчас мы уничтожим x, будет декартово дерево по неявному ключу.

Теперь у нас есть массив от [0 $\cdots$ N - 1](как бы x).

У каждого поддерева будет своя нумерация. То есть у корня будет нумерация от [0, N - 1]. Теперь в
левом поддереве элементы нумеруются [0, $c_l - 1$], у корня номер $с_l$, у правого поддерева с точки зрения корня
элементы [$c_l$ + 1, N - 1], а с точки зрение правого поддерева [0 $\cdots c_r - 1$].

\begin{cppcode}
split (tree T, int k, tree &L, tree &R) {
    if (!T) {
        L = R = NULL;
        return;
    } else if (k < $c_l$) {  // в зависимости от того, что вы поставите < или <= вы включаете элемент или нет.
        split(T->left, k, L, T->left);
        R = T;
    } else {
        split(T->right, k - ($c_l$ + 1), T->right, R);
        L = T;
    }
}
\end{cppcode} 

Рассмотрим операцию перевернуть отрезок.

\begin{cppcode}
struct Node {
   Node *left, right
   int y, c, v;
   bool r;
};

reverse(tree T) {
    T->r = !T->r;
}

push(tree T) {
    if (T->r) {
        reverse(T->left);
        reverse(T->right);
        swap(T->left, T->right);
        T->r = false;
    }    
}
\end{cppcode}

C изменением на отрезке нет никакой разницы, то есть вытаскиваем отрезок и можем с ним что-то сделать, так 
же как и в дереве отрезков можем завести функцию relax и функцию push.

\begin{cppcode}
walk(tree T, int l, int r, a, b) {
    if (r < a || b < l) return;
    if (a <= l && r <= b) {
        whole(T, ...);
        return;
    }
    push(T);
    walk(T->left, l, T->x - 1, a, b);
    handle(T);
    walk(T->right, T->x + 1, r, a, b);
    relax(T);
}
\end{cppcode}
