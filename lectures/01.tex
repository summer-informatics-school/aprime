\chapter{Строки}
\section{Префикс-функция} 

\begin{Def}
Пусть дана строка $s$ длины $n$. 
\begin{enumerate}
\item Тогда подстрокой строки $s$ называется строка $s[i \dots j]$, где $0 \le i \le j < n$.
\item Префиксом называются подстроки, где $i = 0$
\item Cуффиксом "--- подстроки, где $j = n - 1$.
\end{enumerate}
\end{Def}

\begin{Def}
Пусть дана строка $s$. 

Префикс-функция $p[i]$ для строки $s$, длина наибольшего префикса строки $s[0 \dots i)$(не совпадающий со всей строкой), который одновременно является её суффиксом.

Более формально $p[i] = \max n < i \colon s[0 \dots n) = s[i - n \dots i)$.
\end{Def}

\begin{cppcode}
vector <int> p(n);
p[0] = 0;
for (int i = 1; i < n; ++i) {
    p[i] = p[i - 1];
    while (p[i] != 0 && s[p[i]] != s[i]) {
        p[i] = p[p[i] - 1];
    }
    if (s[p[i]] == s[i]) ++p[i];
} 
\end{cppcode}

\subsection{Поиск подстроки в строке. Алгоритм Кнута-Морриса-Пратта.}

\textbf{Задача: }Даны две строки $s$ и $t$. $s$ "--- образец, а $t$ "--- текст. 
Нужно найти все вхождения образца в текст. 

\begin{proof}
Будем решать с помощью префикс-функции. 

Создадим новую строку, являющейся конкатенацией трех строк \cpp"str = s + symb + t", где 
\cpp"symb" "--- строка состоящая из одного символа, не входящего ни в $s$, ни в $t$ (стоп-символ). 
На полученной строке посчитаем префикс-функцию. 
В местах где префикс функция равна длине строки $s$, там заканчивается очередное вхождение образца в текст.
\end{proof}

\section{z-функция}

\begin{Def}
$z$-функция от строки $s$ "--- это массив $z$, такое что $z[i]$ равно наидлиннейшему префиксу подстроки, начинающейся с позиции $i$ в строке $s$,
 который одновременно является и префиксом всей строки $s$.

$$z[i] = LCP[0,i]$$

где $LCP$ "--- это наибольший общий префикс (longest common prefix).
\end{Def}

\begin{cppcode}
int z[maxn];
int l = 0, r = 0; //[l, r)

for (int i = 1; i < n; ++i) {
    if (z[i - l] < r - i) {
        z[i] = z[i - l];
    } else {
        z[i] = max(r - i, 0);
        l = i;
        r = i + z[i];
        while (s[z[i]] == s[i + z[i]]) {
            ++z[i];
            ++r;
        }
    }
}

z[0] = n;
\end{cppcode}

\section{Хеши} 

Хеши строчки($s_0\cdot p^{n - 1} + \cdots + s_{n - 1} \cdot p^{0}$):

\begin{cppcode}
h[0] = 0;
for (int i = 1; i <= n; ++i) {
    h[i] = s[i - 1] + h[i - 1] * pr;
}
\end{cppcode}


Хеш подстроки:
\begin{cppcode}
long long int Hash(int l, int r) {
    return h[r] - p[r - l + 1] * h[l - 1];
}
\end{cppcode}

\begin{enumerate}
\item $\forall <p, M> \exists Hash(s_1) = Hash(s_2)$ "--- анти-хеш тест.
\item $<p = rand, M = rand>$ "--- неизвестно как построить анти-хеш тест.
\item $<p = rand, M>$ "--- строка Туе-Морса является анти-хеш тестом.
\end{enumerate}

Правильно брать два рандомных p и фиксированное простое M.

Сравнение строк = бинпоиск по ответу и сравнение префиксов. 

Парадокс дней рождений (если $k \ge \sqrt{2M}$, то вероятность коллизии больше $\frac12$)
\begin{proof}
$$1 \cdot \frac{M - 1}{M} \cdot \cdots \cdot \frac{M - k}{M} = \left( 1 - \frac{1}{M} \right) \cdot \left( 1 - \frac{2}{M} \right) \cdots \left( 1 - \frac{k}{M} \right) = $$
$$e^{\ln (1 - \frac{1}{M}) \cdots (1 - \frac{k}{M})} = e^{\sum_1^k ln(1 - \frac{i}{M})} \approx e^{\sum_1^k(- \frac{i}{M})} = e^{-\frac{k(k + 1)}{2M}} \approx \frac{1}{e}$$
\end{proof} 

\section{Бор}

\begin{Def}
Бор - структура для хранения множества строк. Дерево, на каждом ребре которого написана буква. Каждой вершине дерева соответствует строчка - последовательность символов на пути до нее от корня. Вершины, соответствующие строкам из множества помечаются терминальными. 
\end{Def}


Добавление строки:

\begin{cppcode}
struct Node {
    static const int ALPHABET = 26;
    int go[ALPHABET];
    bool is_terminal;
    
    Node() : is_terminal(false) {
        memset(go, -1, sizeof(go));
    }
};

Node nodes[MAX_SIZE];
int size = 1;

void add(const string &s) {
    int v = 0;
    for (int i = 0; i < s.size(); ++i) {
        int &ref = nodes[v].go[s[i] - 'a'];
        if (ref == -1)
            ref = size++;
        v = ref; 	
    }
    nodes[v].is_terminal = true;
}
\end{cppcode}

Аналогично выглядит проверка строки на принадлежность множеству - смотрим пришили бы мы в терминальную вершину, если бы добавляли эту строку.

\textbf{Хранение бора:}

Есть несколько вариантов хранения ребер ($V$ - число вершин, $\Sigma$ - размер алфавита, $LEN$ - длина обрабатываемой строки):

\begin{tabular}[c]{llll}
& Mem & Time & Примечания \\
\texttt{Array} & $\Sigma \cdot V$ & $LEN$ &  \\
\texttt{map<int, int>} & $V$ & $LEN \log \Sigma$ & \\
\texttt{unordered\_map<int, int>} & $V \cdot O(1)$ & $LEN \cdot O(1)$ & константы могут быть заметными \\
\end{tabular}

Используем бор для хранения множества строк.

\subsection{Динамика на боре:}
\textbf{Задача:} есть номера городов, одни номера городов являются префиксом других.

Номер относится к номеру с длиннейшим номером города. Посчитать для каждого города количество номеров.

\begin{proof}
Добавляем все вершины в бор, считаем количество номеров у вершины начиная снизу и у каждой вершины храним количество занятых номеров
в поддереве. (Если вершина терминальная, то она занимает все данной длины). Количество номеров у города = max - все занятые номера детей.
\end{proof}

\subsection{Сортировка строк}
Строки можно сортировать стандартной сортировкой и 
строки будут отсортированы за время работы $O(L \log L)$, где
$L$ суммарная длина строк.
